package generator

import java.io.PrintWriter

import parser.ASTNode
import scalaz.syntax.std.boolean._

object GeneratorTraversers {

  val allRegisters: Seq[String] =
    Seq("r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14")

  def traverseMain(symbols: SymbolMemoryTable, ast: ASTNode, writer: PrintWriter): Unit = {
    ast.children.foreach(c => c.value match {
      case "funcBody" =>
        // this is the main function
        traverseFunction(symbols, c, writer)
      case _ => // no op
    })
  }

  def traverseFunction(symbols: SymbolMemoryTable, node: ASTNode, writer: PrintWriter): Unit = {
    node.value match {
      case "assignStatAndVar" =>
        val target = node.children((node.children.size > 3).fold(1, 0))
        traverseAssignStartAndVar(symbols, node.children.last, writer, target.value)
      case _ => node.children.foreach(traverseFunction(symbols, _, writer))
    }
  }

  def traverseAssignStartAndVar(symbols: SymbolMemoryTable, node: ASTNode, writer: PrintWriter, target: String): Unit = {
    node.value match {
      case "optionalAssignOp" =>
        if(node.children.size > 1){
          val expr = computeExpressionResult(symbols, node.children(1), writer, allRegisters)
          writer.write(f"${" "}%-15s sw    $target(r0),$expr %% generated by line ${node.location.row}\n")
        }
      case _ => // noop
    }
  }

  def computeExpressionResult(symbols: SymbolMemoryTable, node: ASTNode, writer: PrintWriter,
                              availableRegisters: Seq[String]): String = {
    node.metadata match {
      case Some("INTEGER") =>
        writer.write(f"${" "}%-15s addi  ${availableRegisters.head},r0,${node.value}\n")
        availableRegisters.head
      case Some("FLOAT") =>
        writer.write(f"${" "}%-15s addi  ${availableRegisters.head},r0,${node.value}\n")
        availableRegisters.head
      case Some("ID") =>
        writer.write(f"${" "}%-15s addi  ${availableRegisters.head},r0,${node.value}(r0)\n")
        availableRegisters.head
      case _ =>
        node.children.foreach(computeExpressionResult(symbols, _, writer, availableRegisters))
        availableRegisters.head
    }
  }

}
